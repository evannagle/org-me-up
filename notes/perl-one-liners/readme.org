#+TITLE: Perl One-Liners
#+AUTHOR: Peteris Krumins
#+DATE: 2014
#+EMAIL: evan@mantle.co
#+CREATOR: Evan Nagle

* Spacing
  :PROPERTIES:
  :header-args: :results scalar 
  :END:

** Print a file

- `perl -n <file>` wraps while loop around program
- `perl -p <file>` wraps while loop around program AND prints (like awk)
- `perl -pe "<command> <file>"` executes command on each line of file   
  
#+BEGIN_SRC sh
perl -pe0 data/lines.txt
# which is the same as:
# perl -pe '' data/lines/txt
#+END_SRC

#+RESULTS:
: line 1
: line 2
: 
: line 3
: line 4

Which is the same as:

#+BEGIN_SRC perl :in-file :results output
open(FILE, "data/lines.txt");

while(<FILE>) {
  # this is where the -e command is inserted
  # our -e command is empty, so I'm empty!
} continue {
  print or die "-p failed: $!\n";
}
#+END_SRC

#+RESULTS:
: line 1
: line 2
: 
: line 3
: line 4

** Double-space a file
#+BEGIN_SRC sh
perl -pe '$\ = "\n"' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1

line 2



line 3

line 4

#+end_example
** Double-space a file (better!)

#+BEGIN_SRC sh
perl -pe 'BEGIN { $\ = "\n" }' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1

line 2



line 3

line 4

#+end_example

** Double-space a file using $_

#+BEGIN_SRC sh
# $_ => the current line
# .= => assignment operator like PHP
perl -pe '$_ .= "\n"' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1

line 2



line 3

line 4

#+end_example

** Double-space a file using substitution

#+BEGIN_SRC sh
perl -pe 's/$/\n/' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1

line 2



line 3

line 4

#+end_example

** Double-space a file using say in Perl 5.10+
   
#+BEGIN_SRC sh
# -n => loop like -p but doesn't print
# -E => same as -e but enables perl 5.10 features
perl -nE 'say' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1

line 2



line 3

line 4

#+end_example

** Double-space a file, excluding the blank lines

#+BEGIN_SRC sh
perl -pe '$_ .= "\n" unless /^$/' data/lines.txt
#+END_SRC

#+RESULTS:
: line 1
: 
: line 2
: 
: 
: line 3
: 
: line 4
: 

** Double-space a file, excluding empty lines

#+BEGIN_SRC sh
perl -pe '$_ .= "\n" if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
: line 1
: 
: line 2
: 
: 
: line 3
: 
: line 4
: 

** Triple-space a file

#+BEGIN_SRC sh
perl -pe '$_ .= "\n\n" if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1


line 2



line 3


line 4


#+end_example

** N-space a file

#+BEGIN_SRC sh
perl -pe '$_ .= "\n"x7 if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1







line 2








line 3







line 4







#+end_example

** Add a blank line before every line

#+BEGIN_SRC sh
perl -pe 's/^/\n/' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example

line 1

line 2



line 3

line 4
#+end_example

** Remove all blank lines

#+BEGIN_SRC sh
perl -ne 'print if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
: line 1
: line 2
: line 3
: line 4

** Remove all consecutive blank lines, leaving only one

#+BEGIN_SRC sh
# -00 => paragarph slurp mode
perl -00pe0 data/lines.txt
#+END_SRC

#+RESULTS:
: line 1
: line 2
: 
: line 3
: line 4

** Compress/expand all blank lines into N consecutive blank lines

#+BEGIN_SRC sh
perl -00pe '$_ .= "\n"x3' data/lines.txt
#+END_SRC

#+RESULTS:
#+begin_example
line 1
line 2




line 3
line 4



#+end_example

** Double-space between words

#+BEGIN_SRC sh
perl -pe 's/ /  /g' data/lines.txt
#+END_SRC

#+RESULTS:
: line  1
: line  2
: 
: line  3
: line  4

** Remove all spacing between words

#+BEGIN_SRC sh
perl -pe 's/ +//g' data/lines.txt
#+END_SRC

#+RESULTS:
: line1
: line2
: 
: line3
: line4

** Change spacing between all words to one space

#+BEGIN_SRC sh
perl -pe 's/ +/ /g' data/lines.txt
#+END_SRC

#+RESULTS:
: line 1
: line 2
: 
: line 3
: line 4

** Insert a space between all characters

#+BEGIN_SRC sh
# -l => l[octal], enable line ending processing 
# without -l, line endings are also gobbled
perl -lpe 's// /g' data/lines.txt
#+END_SRC

#+RESULTS:
:  l i n e   1 
:  l i n e   2 
:  
:  l i n e   3 
:  l i n e   4 

* Numbering
  :PROPERTIES:
  :header-args: :results scalar 
  :END:

** Number all lines in a file

#+BEGIN_SRC sh
perl -pe '$_ = "$..\t$_"' data/lines.txt
#+END_SRC

#+RESULTS:
: 1.	line 1
: 2.	line 2
: 3.	
: 4.	line 3

: 5.	line 4

** Number only non-empty lines in a file

#+BEGIN_SRC sh
# $x is created automatically on first increment
perl -pe '$_ = ++$x . " $_" if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 line 1
: 2 line 2
: 
: 3 line 3
: 4 line 4

** Number only non-empty lines, drop empty lines

#+BEGIN_SRC sh
perl -ne 'print ++$x . " $_" if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 line 1
: 2 line 2
: 3 line 3
: 4 line 4

** Number all lines but print only non-empty lines

#+BEGIN_SRC sh
perl -ne 'print "$. $_" if /\S/' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 line 1
: 2 line 2
: 4 line 3
: 5 line 4

** Number and print only lines that match a pattern

#+BEGIN_SRC sh
perl -ne 'print "Match " . ++$x . ", Line $.: $_" if /line [2-4]/' data/lines.txt
#+END_SRC

#+RESULTS:
: Match 1, Line 2: line 2
: Match 2, Line 4: line 3
: Match 3, Line 5: line 4
** Number all lines in a file using a custom format

#+BEGIN_SRC sh
perl -ne 'printf "%-5d %s", $., $_' data/lines.txt
#+END_SRC

#+RESULTS:
: 1     line 1
: 2     line 2
: 3     
: 4     line 3
: 5     line 4

** Print total number of lines in a file (wc -l)

#+BEGIN_SRC sh
perl -lne 'END { print $. }' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
: 34

** Print total number of lines in a file using context switch

#+BEGIN_SRC sh
perl -e 'print $n = () = <>' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
: 34

** Print the number of non-empty lines in a file

#+BEGIN_SRC sh
perl -le 'print scalar(grep { /./ } <>)' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
: 28

*** Golfing = creating the shortest Perl program that does a particular task
*** ~~ Double bitwise negation => converts list to scalar

#+BEGIN_SRC sh
perl -lE 'say~~grep{/./}<>' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
: 28

** Print the number of empty lines in a file

#+BEGIN_SRC sh
perl -nE 'say~~grep{/^\S/}<>' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
: 13

** Print the number of lines that match a pattern (grep -c)

#+BEGIN_SRC sh
# $x + 0 ensures that 0 is printed if no matches are found
perl -lne '$x++ if /line [1-9]/; END { print $x + 0 }' data/lines.txt
#+END_SRC

#+RESULTS:
: 4

** Number words across all lines

#+BEGIN_SRC sh
# s/regex/replace/ge => the e interprets the replacement as code
perl -pe 's/(\w+)/++$i."[$1]"/ge' data/lines.txt
#+END_SRC

#+RESULTS:
: 1[line] 2[1]
: 3[line] 4[2]
: 
: 5[line] 6[3]
: 7[line] 8[4]

** Number words on each liners

#+BEGIN_SRC sh
perl -pe '$i = 0; s/([aeiou])/++$i."[$1]"/ge' data/lines.txt
#+END_SRC

#+RESULTS:
: l1[i]n2[e] 1
: l1[i]n2[e] 2
: 
: l1[i]n2[e] 3
: l1[i]n2[e] 4

** Replace all words with their numeric positions

#+BEGIN_SRC sh
perl -pe 's/(\w+)/++$i/ge' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 2
: 3 4
: 
: 5 6
: 7 8

* Calculations
  :PROPERTIES:
  :header-args: :results scalar 
  :END:

** Convert number to unary

#+BEGIN_SRC sh :results scalar
perl -lne '(1x$_) !~ /^1?$|^(11+?)\1+$/ && print "$_ is prime"' data/numbers.txt
#+END_SRC

#+RESULTS:
: 2 is prime
: 3 is prime
: 5 is prime
: 7 is prime
: 11 is prime
: 13 is prime
: 17 is prime
: 19 is prime

** Print the sum of all fields on one line

#+BEGIN_SRC sh
# -M => import
# -MList::Util=sum => import sum function from List::Util
# http://perldoc.perl.org/List/Util.html

perl -MList::Util=sum -alne 'print sum @F' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 6
: 15
: 24
: 33
: 42

#+BEGIN_SRC perl
# -MList::Util=sum is equivalent to
use List::Util qw(sum);

@list = 1..5;

sum @list;
#+END_SRC

#+RESULTS:
: 15

** Print sum of all fields on all lines

#+BEGIN_SRC sh
perl -MList::Util=sum -alne '$i += sum @F; END { print $i }' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 120
** Shuffle all fields on each line

#+BEGIN_SRC sh
perl -MList::Util=shuffle -alne 'print join " ", shuffle @F' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 line
: line 2
: 
: line 3
: 4 line
** Find min element on each line

#+BEGIN_SRC sh
perl -MList::Util=min -alne 'print min @F' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 1
: 4
: 7
: 10
: 13
** Find min element in all lines
*** Memory insensitive
#+BEGIN_SRC sh
perl -MList::Util=min -alne '@nums = (@nums, @F); END { print min @nums }' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 1

*** Memory sensitive

#+BEGIN_SRC sh
perl -MList::Util=min -alne '
  $rmin = min @F;
  $min = $rmin unless defined $min and $min < $rmin;
  END { print $min }
' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 1
** Find max element on each line

#+BEGIN_SRC sh
perl -MList::Util=max -alne 'print max(@F)' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 3
: 6
: 9
: 12
: 15

** Find max in entire file

*** Memory insensitive

#+BEGIN_SRC sh
perl -MList::Util=max -alne '@nums = (@nums, @F); END { print max @nums }' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 15

*** Memory sensitive

#+BEGIN_SRC sh
perl -MList::Util=max -alne '
  $rmax = max @F;
  $max = $rmax unless defined $max and $max < $rmas;
  END { print $max }' data/number-grid.txt
#+END_SRC

#+RESULTS:
: 15
** Replace each field with its absolute value

#+BEGIN_SRC sh
perl -alne 'print "@{[map { abs } @F]}"' data/signed-numbers.txt
#+END_SRC

#+RESULTS:
: 1 2 3 4
: 2 1 9 123 4
: 15 2 1.5 4
** Print total number of fields on each line

#+BEGIN_SRC sh
perl -alne 'print scalar @F' data/lines.txt
#+END_SRC

#+RESULTS:
: 2
: 2
: 0
: 2
: 2

** Print the total number of fields on each line, followed by the line

#+BEGIN_SRC sh
perl -alne 'print ~~@F, " $_"' data/lines.txt
#+END_SRC

#+RESULTS:
: 2 line 1
: 2 line 2
: 0 
: 2 line 3
: 2 line 4
** Print the total number of fields on all lines

#+BEGIN_SRC sh
perl -alne '$f += ~~@F; END { print $f }' data/jabberwocky.poem 
#+END_SRC

#+RESULTS:
: 166

** Print the number of fields that match a pattern

*** Less succinct, with map
#+BEGIN_SRC sh
perl -alne 'map { /line/ && $t++ } @F; END { print $t || 0 }' data/lines.txt
#+END_SRC

#+RESULTS:
: 4
*** More succinct, with grep

#+BEGIN_SRC sh
perl -alne '$f += grep /line/, @F; END { print $f || 0 }' data/lines.txt
#+END_SRC

#+RESULTS:
: 4

** Print the total number of lines that match a pattern

#+BEGIN_SRC sh
perl -lne '/line/ && $t++; END { print $t || 0 }' data/lines.txt
#+END_SRC

#+RESULTS:
: 4
** Print the number π

#+BEGIN_SRC sh
perl -Mbignum=bpi -le 'print bpi(21)'
#+END_SRC

#+RESULTS:
: 3.14159265358979323846
** Print the number e

#+BEGIN_SRC sh
perl -Mbignum=bexp -le 'print bexp(2,31)'
#+END_SRC

#+RESULTS:
: 7.389056098930650227230427460575

** Print UNIX time

#+BEGIN_SRC sh
perl -le 'print time'
#+END_SRC

#+RESULTS:
: 1534378425

** Print GMT

#+BEGIN_SRC sh
perl -le 'print ~~gmtime'
#+END_SRC

#+RESULTS:
: Thu Aug 16 00:47:36 2018
** Print Local Time

#+BEGIN_SRC sh
perl -le 'print ~~localtime'
#+END_SRC

#+RESULTS:
: Wed Aug 15 14:48:05 2018
** Print yesterday's date

#+BEGIN_SRC sh
perl -MPOSIX -le '
  @now = localtime;
  $now[3] -= 1;
  print ~~localtime mktime @now
'
#+END_SRC

#+RESULTS:
: Tue Aug 14 14:49:07 2018

** Print the date 14 months, 9 days and 7 seconds ago

#+BEGIN_SRC sh
perl -MPOSIX -le '
  @now = localtime;
  $now[0] -= 7;
  $now[3] -= 9;
  $now[4] -= 14;
  print ~~localtime mktime @now'
#+END_SRC

#+RESULTS:
: Tue Jun  6 15:10:13 2017

** Calculate the factorial

#+BEGIN_SRC sh
perl -MMath::BigInt -le 'print Math::BigInt->new(5)->bfac()'
#+END_SRC

#+RESULTS:
: 120
** Calculate greatest common divisor

#+BEGIN_SRC sh
perl -MMath::BigInt=bgcd -le 'print bgcd(20,60,30)'
#+END_SRC

#+RESULTS:
: 10
** Calculate the least common multiple

#+BEGIN_SRC sh
perl -MMath::BigInt=blcm -le 'print blcm(35,20,8)'
#+END_SRC

#+RESULTS:
: 280
** Generate 10 random numbers between 5 and 15

#+BEGIN_SRC sh
perl -le 'print join ",", map { int(rand(15-5)) + 5 } 1..10' 
#+END_SRC

#+RESULTS:
: 11,14,14,12,7,11,5,13,6,12
** Generate all permutations of a list

#+BEGIN_SRC sh

# need to install Algorithm::Permute for this
# or at least I did...
# perl -MCPAN -e 'install Algorithm::Permute'

perl -MAlgorithm::Permute -le '
  $l = [1,2,3,4,5];
  $p = Algorithm::Permute->new($l);
  print "@r" while @r = $p->next'
#+END_SRC

#+RESULTS:
#+begin_example
5 4 3 2 1
4 5 3 2 1
4 3 5 2 1
4 3 2 5 1
4 3 2 1 5
5 3 4 2 1
3 5 4 2 1
3 4 5 2 1
3 4 2 5 1
3 4 2 1 5
5 3 2 4 1
3 5 2 4 1
3 2 5 4 1
3 2 4 5 1
3 2 4 1 5
5 3 2 1 4
3 5 2 1 4
3 2 5 1 4
3 2 1 5 4
3 2 1 4 5
5 4 2 3 1
4 5 2 3 1
4 2 5 3 1
4 2 3 5 1
4 2 3 1 5
5 2 4 3 1
2 5 4 3 1
2 4 5 3 1
2 4 3 5 1
2 4 3 1 5
5 2 3 4 1
2 5 3 4 1
2 3 5 4 1
2 3 4 5 1
2 3 4 1 5
5 2 3 1 4
2 5 3 1 4
2 3 5 1 4
2 3 1 5 4
2 3 1 4 5
5 4 2 1 3
4 5 2 1 3
4 2 5 1 3
4 2 1 5 3
4 2 1 3 5
5 2 4 1 3
2 5 4 1 3
2 4 5 1 3
2 4 1 5 3
2 4 1 3 5
5 2 1 4 3
2 5 1 4 3
2 1 5 4 3
2 1 4 5 3
2 1 4 3 5
5 2 1 3 4
2 5 1 3 4
2 1 5 3 4
2 1 3 5 4
2 1 3 4 5
5 4 3 1 2
4 5 3 1 2
4 3 5 1 2
4 3 1 5 2
4 3 1 2 5
5 3 4 1 2
3 5 4 1 2
3 4 5 1 2
3 4 1 5 2
3 4 1 2 5
5 3 1 4 2
3 5 1 4 2
3 1 5 4 2
3 1 4 5 2
3 1 4 2 5
5 3 1 2 4
3 5 1 2 4
3 1 5 2 4
3 1 2 5 4
3 1 2 4 5
5 4 1 3 2
4 5 1 3 2
4 1 5 3 2
4 1 3 5 2
4 1 3 2 5
5 1 4 3 2
1 5 4 3 2
1 4 5 3 2
1 4 3 5 2
1 4 3 2 5
5 1 3 4 2
1 5 3 4 2
1 3 5 4 2
1 3 4 5 2
1 3 4 2 5
5 1 3 2 4
1 5 3 2 4
1 3 5 2 4
1 3 2 5 4
1 3 2 4 5
5 4 1 2 3
4 5 1 2 3
4 1 5 2 3
4 1 2 5 3
4 1 2 3 5
5 1 4 2 3
1 5 4 2 3
1 4 5 2 3
1 4 2 5 3
1 4 2 3 5
5 1 2 4 3
1 5 2 4 3
1 2 5 4 3
1 2 4 5 3
1 2 4 3 5
5 1 2 3 4
1 5 2 3 4
1 2 5 3 4
1 2 3 5 4
1 2 3 4 5
#+end_example
** Generate the powerset

#+BEGIN_SRC sh
# perl -MCPAN -e 'install List::PowerSet'

perl -MList::PowerSet=powerset -le '
  @l = (1,2,3,4,5);
  print "@$_" for @{powerset(@l)}'
#+END_SRC

#+RESULTS:
#+begin_example
1 2 3 4 5
2 3 4 5
1 3 4 5
3 4 5
1 2 4 5
2 4 5
1 4 5
4 5
1 2 3 5
2 3 5
1 3 5
3 5
1 2 5
2 5
1 5
5
1 2 3 4
2 3 4
1 3 4
3 4
1 2 4
2 4
1 4
4
1 2 3
2 3
1 3
3
1 2
2
1

#+end_example
** Convert an IP address to an unsigned integer

#+BEGIN_SRC sh
perl -le '
  $i = 3;
  $u += ($_<<8*$i--) for "127.0.0.1" =~ /(\d+)/g;
  print $u;
'
#+END_SRC

#+RESULTS:
: 2130706433
** Convert an unsigned integer to an IP address

#+BEGIN_SRC sh
perl -MSocket -le 'print inet_ntoa(pack("N", 2130706433))'
#+END_SRC

#+RESULTS:
: 127.0.0.1
* Working with Arrays and Strings
** Generate and print the alphabet

#+BEGIN_SRC sh
perl -le 'print a..z'
#+END_SRC

#+RESULTS:
: abcdefghijklmnopqrstuvwxyz
** Generate and print the alphabet with a delimiter

#+BEGIN_SRC sh :results scalar
perl -le "$, = ','; print ('a'..'z')"
#+END_SRC

#+RESULTS:
: a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
** Create a hex lookup table

#+BEGIN_SRC sh
perl -le "printf('%x', 255)"
#+END_SRC

#+RESULTS:
: ff
** Convert number back from hex to dec

#+BEGIN_SRC sh
perl -le '$num = "ff"; print hex $num'
#+END_SRC

#+RESULTS:
: 255
** Generate a random number

#+BEGIN_SRC sh
perl -le "print rand 26"
#+END_SRC

#+RESULTS:
: 4.58638578798318

** Generate a random password

#+BEGIN_SRC sh
perl -le 'print map { ("a".."z")[rand 26] } 1..8'
#+END_SRC

#+RESULTS:
: vnweuhvn
  
** Create a string of a specific length

#+BEGIN_SRC sh
perl -le 'print "x"' 
#+END_SRC

#+RESULTS:
: x

#+BEGIN_SRC sh
perl -le 'print "a"x10'
#+END_SRC

#+RESULTS:
: aaaaaaaaaa

** Create an array from a string 

#+BEGIN_SRC sh :results scalar
perl -le '@friends = qw/Jim John Joan/; print (join ", ", @friends)'
#+END_SRC

#+RESULTS:
: Jim, John, Joan

** Create a string from the command-line arguments

#+BEGIN_SRC sh :results scalar
perl -le 'print (join ", ", @ARGV)' val1 val2 val3
#+END_SRC

#+RESULTS:
: val1, val2, val3

** Find the numeric values for characters in a string

#+BEGIN_SRC sh :results scalar
perl -le 'print join ", ", map { ord } split //, "hello, world"'
#+END_SRC

#+RESULTS:
: 104, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100

** Find the hex values for characters in a string

#+BEGIN_SRC sh :results scalar
perl -le '
  print join ", ", map { sprintf "0x%x", ord $_ } split //, "hello, world"
'
#+END_SRC

#+RESULTS:
: 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64

** Find the octal values for characters in a string

#+BEGIN_SRC sh :results scalar
perl -le '
  print join ", ", map { sprintf "%#o", ord $_ } split //, "hello, world"
'
#+END_SRC

#+RESULTS:
: 0150, 0145, 0154, 0154, 0157, 054, 040, 0167, 0157, 0162, 0154, 0144

** Convert a list of ASCII values into a string

#+BEGIN_SRC sh
perl -le '
  @ascii = qw/99 111 100 105 110 103/;
  print pack("C*", @ascii);
'
#+END_SRC

#+RESULTS:
: coding

** Generate an array with odd numbers from 1 to 100

#+BEGIN_SRC sh :results scalar
perl -le '
  @odd = grep { $_ % 2 == 1 } 1..100;
  print join ", ", @odd;
'
#+END_SRC

#+RESULTS:
: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99

** Generate an array with even numbers from 1 to 100

#+BEGIN_SRC sh :results scalar
perl -le '
  @even = grep { $_ % 2 == 0 } 1..100;
  print join ", ", @even;
'
#+END_SRC

#+RESULTS:
: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100

** Find the length of a string

#+BEGIN_SRC sh
perl -le 'print length "foo"'
#+END_SRC

#+RESULTS:
: 3

** Find the number of elements in an array

#+BEGIN_SRC sh
perl -le '
  @a = qw/one two three/;
  print ~~@a;
'
#+END_SRC

#+RESULTS:
: 3

* Text Conversion and Substitution
** y operator = transliterate

#+BEGIN_SRC sh
perl -le '
  $str = "foo";
  $str =~ y/fo/ga/;
  print $str;
'
#+END_SRC

#+RESULTS:
: gaa

** ROT13 a string

#+BEGIN_SRC sh
perl -le '
  $string = "bananas";
  $string =~ y/A-Za-z/N-ZA-Mn-za-m/;
  print $string
'
#+END_SRC

#+RESULTS:
: onananf

** Base64-encode a string

#+BEGIN_SRC sh
perl -MMIME::Base64 -e 'print encode_base64("string")'
#+END_SRC

#+RESULTS:
: c3RyaW5n

** Base64-decode a string

#+BEGIN_SRC sh
perl -MMIME::Base64 -e 'print decode_base64("c3RyaW5n")'
#+END_SRC

#+RESULTS:
: string

** URL-escape a string

#+BEGIN_SRC sh
perl -MURI::Escape -le 'print uri_escape("https://mantle.co")'
#+END_SRC

#+RESULTS:
: https%3A%2F%2Fmantle.co

** URL-unescape a string

#+BEGIN_SRC sh
perl -MURI::Escape -le 'print uri_unescape("https%3A%2F%2Fmantle")'
#+END_SRC

#+RESULTS:
: https://mantle
** HTML-encode a string

#+BEGIN_SRC sh
perl -MHTML::Entities -le 'print encode_entities("<html>")'
#+END_SRC

#+RESULTS:
: &lt;html&gt;

** HTML-decode a string

#+BEGIN_SRC sh
perl -MHTML::Entities -le 'print decode_entities("&lt;html&gt;")'
#+END_SRC

#+RESULTS:
: <html>

** Convert all text to uppercase

#+BEGIN_SRC sh :results scalar
perl -le '
  $a = "foo";
  print uc $a;
'

perl -le '
  $a = "foo";
  $a =~ y/[a-z]/[A-Z]/;
  print $a;
'

perl -le 'print "\Ufoo"'
#+END_SRC

#+RESULTS:
: FOO
: FOO
: FOO

** Convert all text to lowercase

#+BEGIN_SRC sh :results scalar
perl -le '
  $a = "FOO";
  print lc $a;
'

perl -le '
  $a = "FOO";
  $a =~ y/[A-Z]/[a-z]/;
  print $a;
'

perl -le 'print "\LFOO"'
#+END_SRC

#+RESULTS:
: foo
: foo
: foo

** Uppercase first letter of each line

#+BEGIN_SRC sh :results scalar
perl -nle 'print "\u\L$_"' data/lines.txt
#+END_SRC

#+RESULTS:
: Line 1
: Line 2
: 
: Line 3
: Line 4

** Invert the letter case

#+BEGIN_SRC sh
perl -ple 'y/[A-Za-z]/[a-zA-Z]/' data/lines.txt
#+END_SRC

#+RESULTS:
| LINE | 1 |
| LINE | 2 |
|      |   |
| LINE | 3 |
| LINE | 4 |

** Title Case each line

#+BEGIN_SRC sh :results scalar
perl -ple 's/(\w+)/\u$1/g' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Twas Brillig, And The Slithy Toves 
      Did Gyre And Gimble In The Wabe: 
All Mimsy Were The Borogoves, 
      And The Mome Raths Outgrabe. 

“Beware The Jabberwock, My Son! 
      The Jaws That Bite, The Claws That Catch! 
Beware The Jubjub Bird, And Shun 
      The Frumious Bandersnatch!” 

He Took His Vorpal Sword In Hand; 
      Long Time The Manxome Foe He Sought— 
So Rested He By The Tumtum Tree 
      And Stood Awhile In Thought. 

And, As In Uffish Thought He Stood, 
      The Jabberwock, With Eyes Of Flame, 
Came Whiffling Through The Tulgey Wood, 
      And Burbled As It Came! 

One, Two! One, Two! And Through And Through 
      The Vorpal Blade Went Snicker-Snack! 
He Left It Dead, And With Its Head 
      He Went Galumphing Back. 

“And Hast Thou Slain The Jabberwock? 
      Come To My Arms, My Beamish Boy! 
O Frabjous Day! Callooh! Callay!” 
      He Chortled In His Joy. 

’Twas Brillig, And The Slithy Toves 
      Did Gyre And Gimble In The Wabe: 
All Mimsy Were The Borogoves, 
      And The Mome Raths Outgrabe.
#+end_example

** Strip leading whitespace

#+BEGIN_SRC sh :results scalar
perl -ple 's/^\s+//' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Twas brillig, and the slithy toves 
Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
And the mome raths outgrabe. 

“Beware the Jabberwock, my son! 
The jaws that bite, the claws that catch! 
Beware the Jubjub bird, and shun 
The frumious Bandersnatch!” 

He took his vorpal sword in hand; 
Long time the manxome foe he sought— 
So rested he by the Tumtum tree 
And stood awhile in thought. 

And, as in uffish thought he stood, 
The Jabberwock, with eyes of flame, 
Came whiffling through the tulgey wood, 
And burbled as it came! 

One, two! One, two! And through and through 
The vorpal blade went snicker-snack! 
He left it dead, and with its head 
He went galumphing back. 

“And hast thou slain the Jabberwock? 
Come to my arms, my beamish boy! 
O frabjous day! Callooh! Callay!” 
He chortled in his joy. 

’Twas brillig, and the slithy toves 
Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
And the mome raths outgrabe.
#+end_example

** Strip trailing whitespace

#+BEGIN_SRC sh :results scalar
perl -ple 's/\s+$//' data/jabberwocky.poem 
#+END_SRC

#+RESULTS:
#+begin_example
’Twas brillig, and the slithy toves
      Did gyre and gimble in the wabe:
All mimsy were the borogoves,
      And the mome raths outgrabe.

“Beware the Jabberwock, my son!
      The jaws that bite, the claws that catch!
Beware the Jubjub bird, and shun
      The frumious Bandersnatch!”

He took his vorpal sword in hand;
      Long time the manxome foe he sought—
So rested he by the Tumtum tree
      And stood awhile in thought.

And, as in uffish thought he stood,
      The Jabberwock, with eyes of flame,
Came whiffling through the tulgey wood,
      And burbled as it came!

One, two! One, two! And through and through
      The vorpal blade went snicker-snack!
He left it dead, and with its head
      He went galumphing back.

“And hast thou slain the Jabberwock?
      Come to my arms, my beamish boy!
O frabjous day! Callooh! Callay!”
      He chortled in his joy.

’Twas brillig, and the slithy toves
      Did gyre and gimble in the wabe:
All mimsy were the borogoves,
      And the mome raths outgrabe.
#+end_example

** Strip whitespace from beginning and end of line

#+BEGIN_SRC sh :results scalar
perl -ple 's/^\s+|\s+$//' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Twas brillig, and the slithy toves
Did gyre and gimble in the wabe: 
All mimsy were the borogoves,
And the mome raths outgrabe. 

“Beware the Jabberwock, my son!
The jaws that bite, the claws that catch! 
Beware the Jubjub bird, and shun
The frumious Bandersnatch!” 

He took his vorpal sword in hand;
Long time the manxome foe he sought— 
So rested he by the Tumtum tree
And stood awhile in thought. 

And, as in uffish thought he stood,
The Jabberwock, with eyes of flame, 
Came whiffling through the tulgey wood,
And burbled as it came! 

One, two! One, two! And through and through
The vorpal blade went snicker-snack! 
He left it dead, and with its head
He went galumphing back. 

“And hast thou slain the Jabberwock?
Come to my arms, my beamish boy! 
O frabjous day! Callooh! Callay!”
He chortled in his joy. 

’Twas brillig, and the slithy toves
Did gyre and gimble in the wabe: 
All mimsy were the borogoves,
And the mome raths outgrabe.
#+end_example

** Replace one string with another in a file

#+BEGIN_SRC sh :results scalar
perl -pe 's/a/_/' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Tw_s brillig, and the slithy toves 
      Did gyre _nd gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome r_ths outgrabe. 

“Bew_re the Jabberwock, my son! 
      The j_ws that bite, the claws that catch! 
Bew_re the Jubjub bird, and shun 
      The frumious B_ndersnatch!” 

He took his vorp_l sword in hand; 
      Long time the m_nxome foe he sought— 
So rested he by the Tumtum tree 
      And stood _while in thought. 

And, _s in uffish thought he stood, 
      The J_bberwock, with eyes of flame, 
C_me whiffling through the tulgey wood, 
      And burbled _s it came! 

One, two! One, two! And through _nd through 
      The vorp_l blade went snicker-snack! 
He left it de_d, and with its head 
      He went g_lumphing back. 

“And h_st thou slain the Jabberwock? 
      Come to my _rms, my beamish boy! 
O fr_bjous day! Callooh! Callay!” 
      He chortled in his joy. 

’Tw_s brillig, and the slithy toves 
      Did gyre _nd gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome r_ths outgrabe.
#+end_example

** Replace one string with another on lines that match a pattern

#+BEGIN_SRC sh :results scalar
perl -pe '/^\s+Did/ && s/[aeiou]/_/' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Twas brillig, and the slithy toves 
      D_d gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe. 

“Beware the Jabberwock, my son! 
      The jaws that bite, the claws that catch! 
Beware the Jubjub bird, and shun 
      The frumious Bandersnatch!” 

He took his vorpal sword in hand; 
      Long time the manxome foe he sought— 
So rested he by the Tumtum tree 
      And stood awhile in thought. 

And, as in uffish thought he stood, 
      The Jabberwock, with eyes of flame, 
Came whiffling through the tulgey wood, 
      And burbled as it came! 

One, two! One, two! And through and through 
      The vorpal blade went snicker-snack! 
He left it dead, and with its head 
      He went galumphing back. 

“And hast thou slain the Jabberwock? 
      Come to my arms, my beamish boy! 
O frabjous day! Callooh! Callay!” 
      He chortled in his joy. 

’Twas brillig, and the slithy toves 
      D_d gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe.
#+end_example
** Print paragraphs in reverse order

#+BEGIN_SRC sh :results scalar
perl -00 -e 'print reverse <>' data/jabberwocky.poem
#+END_SRC

#+RESULTS:
#+begin_example
’Twas brillig, and the slithy toves 
      Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe.
“And hast thou slain the Jabberwock? 
      Come to my arms, my beamish boy! 
O frabjous day! Callooh! Callay!” 
      He chortled in his joy. 

One, two! One, two! And through and through 
      The vorpal blade went snicker-snack! 
He left it dead, and with its head 
      He went galumphing back. 

And, as in uffish thought he stood, 
      The Jabberwock, with eyes of flame, 
Came whiffling through the tulgey wood, 
      And burbled as it came! 

He took his vorpal sword in hand; 
      Long time the manxome foe he sought— 
So rested he by the Tumtum tree 
      And stood awhile in thought. 

“Beware the Jabberwock, my son! 
      The jaws that bite, the claws that catch! 
Beware the Jubjub bird, and shun 
      The frumious Bandersnatch!” 

’Twas brillig, and the slithy toves 
      Did gyre and gimble in the wabe: 
All mimsy were the borogoves, 
      And the mome raths outgrabe. 

#+end_example

** Print all lines in reverse order

#+BEGIN_SRC sh :results scalar
perl -lne 'print scalar reverse' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 enil
: 2 enil
: 
: 3 enil
: 4 enil

** Print columns in reverse order

#+BEGIN_SRC sh :results scalar
perl -alne '
  print "@{[reverse @F]}"; # quotes are important here
' data/lines.txt
#+END_SRC

#+RESULTS:
: 1 line
: 2 line
: 
: 3 line
: 4 line
