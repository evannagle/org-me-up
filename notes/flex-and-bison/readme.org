#+TITLE: Flex & Bison
#+AUTHOR: John Levin
#+DATE: 2009
#+EMAIL: evan@mantle.co
#+CREATOR: Evan Nagle
#+TAGS: @c @linux @flex @bison

* Introduction
** Lexing = scanning = parsing text into tokens
** Parsing = determines relationship amongst tokens
** Structure of a Lex/Bison file:   

%{
//PROLOGUE in C
#include <stdio.h>
#define BRITNEY "spears"
%}

%%

Grammar Rules

%%

Epilogue

int main(int argc, char **argv) {
  printf("%s\n", "here we go!");
  yylex(); ==> runs the lexer
  return 0;
}

** Simple Flex Makefile

#+BEGIN_SRC Makefile
APP       = app
APP_L     = $(APP).l
LC        = flex
LFLAGS    = 
CC        = gcc
CFLAGS    =

all: $(APP)

# lex.yy.c is the file outputted by Flex
# running flex app.l
lex.yy.c: $(APP_L)
    $(LC) $(LFLAGS) $(APP_L)

# running gcc -o app lex.yy.c
$(APP): lex.yy.c
    $(CC) $(CFLAGS) -o $(APP) lex.yy.c

#+END_SRC
** Sample: wc

#+BEGIN_SRC sh
echo "here I am" | ./data/wc/wc
#+END_SRC

#+RESULTS:
| chars: | 10 |
| words: |  3 |
| lines: |  1 |


** Sample: colour

#+BEGIN_SRC sh
echo "What colour is this?" | ./data/colour/colour
#+END_SRC

#+RESULTS:
: What color is this?

** Sample: dumber

#+BEGIN_SRC sh :results scalar
echo "1 + 2 * 10 / 5x" | ./data/dumbers/dumbers
#+END_SRC

#+RESULTS:
: NUMBER 1
: PLUS
: NUMBER 2
: TIMES
: NUMBER 10
: DIVIDE
: NUMBER 5
: MYSTERY CHAR x
: NEWLINE
