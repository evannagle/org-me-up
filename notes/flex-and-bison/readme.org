#+TITLE: Flex & Bison
#+AUTHOR: John Levin
#+DATE: 2009
#+EMAIL: evan@mantle.co
#+CREATOR: Evan Nagle
#+TAGS: @c @linux @flex @bison

* Introduction
** Lexing = scanning = parsing text into tokens
** Parsing = determines **relationship** amongst tokens
   Converts stream of tokens into a tree of tokens.
** Structure of a Lex/Bison file:   

   %{
   //PROLOGUE in C
   #include <stdio.h>
   #define BRITNEY "spears"
   %}

   %%

   Grammar Rules

   %%

   Epilogue

   int main(int argc, char **argv) {
   printf("%s\n", "here we go!");
   yylex(); ==> runs the lexer
   return 0;
   }

** Simple Flex Makefile

   #+BEGIN_SRC Makefile
APP       = app
APP_L     = $(APP).l
LC        = flex
LFLAGS    = 
CC        = gcc
CFLAGS    =

all: $(APP)

# lex.yy.c is the file outputted by Flex
# running flex app.l
lex.yy.c: $(APP_L)
    $(LC) $(LFLAGS) $(APP_L)

# running gcc -o app lex.yy.c
$(APP): lex.yy.c
    $(CC) $(CFLAGS) -o $(APP) lex.yy.c

   #+END_SRC
* Some Flex-Only Examples
** wc

   #+BEGIN_SRC sh
echo "here I am" | ./data/wc/wc
   #+END_SRC

   #+RESULTS:
   | chars: | 10 |
   | words: |  3 |
   | lines: |  1 |


** wc with file management
   
#+BEGIN_SRC sh
./data/wcf/wc ./data/wcf/*.poem
#+END_SRC

#+RESULTS:
| ./data/wcf/hunting-of-the-snark.poem | 25581 | 4519 |  724 |
| ./data/wcf/jabberwocky.poem          | 26639 | 4686 |  757 |
| *TOTAL*                              | 52220 | 9205 | 1481 |

** colour

   #+BEGIN_SRC sh
echo "What colour is this?" | ./data/colour/colour
   #+END_SRC

   #+RESULTS:
   : What color is this?

** dumber

   #+BEGIN_SRC sh :results scalar
echo "1 + 2 * 10 / 5x" | ./data/dumbers/dumbers
   #+END_SRC

   #+RESULTS:
   : NUMBER 1
   : PLUS
   : NUMBER 2
   : TIMES
   : NUMBER 10
   : DIVIDE
   : NUMBER 5
   : MYSTERY CHAR x
   : NEWLINE

** number lexer

   #+BEGIN_SRC sh
echo "1 * 24 - 14" | ./data/number-scanner/number-scanner
   #+END_SRC

   #+RESULTS:
   | 258 |  1 |
   | 261 |    |
   | 258 | 24 |
   | 260 |    |
   | 258 | 14 |
   | 264 |    |

* Bison and Flex Together
** In flex.l file  
*** remove enum yytokentype
*** also remove int yylval
*** also remove the int main() call   
*** import flex.tab.h, which is generated by bison   
** Sample: calculator

   #+BEGIN_SRC sh
echo "10 - 5" | ./data/calculator/calculator
echo "10 + 5" | ./data/calculator/calculator
echo "5 * 5" | ./data/calculator/calculator
echo "15 / 3 * 2" | ./data/calculator/calculator
   #+END_SRC

   #+RESULTS:
   | = |  5 |
   | = | 15 |
   | = | 25 |
   | = | 10 |

** Sample: calculator with parens and comments

   #+BEGIN_SRC sh
./data/calculator-p/calculator <<<'5 * (5 + 1) //should be thirty'
   #+END_SRC

   #+RESULTS:
   : = 30

** Sample: calculator with hand-written lexer

* Flex Regexes

  |---------+------------------------------------------------------------------------------------------|
  | pattern | matches                                                                                  |
  |---------+------------------------------------------------------------------------------------------|
  | .       | Any single char except \n                                                                |
  | []      | Character class                                                                          |
  | ^       | Beginning of line                                                                        |
  | $       | End of line                                                                              |
  | {}      | Min and max occurrences                                                                  |
  | \       | Escape                                                                                   |
  | **      | Zero or more occurrences                                                                 |
  | +       | One or more occurrences                                                                  |
  | ?       | Zero or one occurrences                                                                  |
  | \vert   | Or operator                                                                              |
  | "..."   | Literal expression                                                                       |
  | ()      | Group                                                                                    |
  | /       | Trailing context. Match regex preceding slash only if followed by regex proceeding slash |
  |---------+------------------------------------------------------------------------------------------|

** Ambiguous Patterns
*** It's hungry. Matches the longest possible string every pass.
*** If there's a tie, use the pattern that appears first in the expressions list.
